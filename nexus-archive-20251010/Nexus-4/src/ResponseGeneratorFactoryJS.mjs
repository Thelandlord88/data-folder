/**
 * Enhanced Response Generator Factory - Auto-Generation System
 * Creates specialized generators: hard-coded > auto-generated > generic
 */

import { PersonalityGeneratorTemplate } from './PersonalityGeneratorTemplate.mjs';

// Generic response generator for personalities without specialized implementation
class GenericResponseGenerator {
  generateResponse(request, personality, principles, context) {
    return {
      content: `### ðŸ§  ${personality.identity?.name || 'NEXUS Agent'} Generic Response

**Request**: ${request}

### Standard Cognitive Processing
This personality does not have specialized traits or hard-coded generator. Using generic NEXUS patterns.

**Analysis**: Standard systematic thinking patterns applied to your request.
**Recommendation**: Define cognitive traits for this personality to enable auto-generated specialized responses.`,
      personalityUsed: personality.identity?.name || 'Generic',
      nexusEnhanced: true,
      traitApplications: ['generic-processing'],
      specialtyInsights: [],
      confidenceScore: 0.4,
      analysisDepth: 'surface',
      processingType: 'generic-fallback'
    };
  }

  getSpecialtyAnalysis(request) {
    return [];
  }

  getTraitApplication(request, traits) {
    return traits.map(trait => ({
      trait,
      application: 'Generic trait application',
      strength: 0.4
    }));
  }

  calculateConfidence(request, domain) {
    return 0.4;
  }
}

export class ResponseGeneratorFactory {
  constructor(personalityRegistry = null) {
    this.generators = new Map();
    this.personalityRegistry = personalityRegistry || new Map();
    this.genericGenerator = new GenericResponseGenerator();
    this.autoGeneratedCache = new Map();
    this.initializeGenerators();
  }
  
  async initializeGenerators() {
    try {
      // Try to load hard-coded specialized generators
      const daedalusModule = await import('./DaedalusResponseGenerator.mjs');
      this.generators.set('daedalus', new daedalusModule.DaedalusResponseGenerator());
      
      const hunterModule = await import('./HunterResponseGenerator.mjs');
      this.generators.set('hunter', new hunterModule.HunterResponseGenerator());
      
      console.log(`ðŸ§¬ Hard-coded generators initialized: ${Array.from(this.generators.keys()).join(', ')}`);
    } catch (error) {
      console.warn('âš ï¸ Could not load all hard-coded generators:', error.message);
    }
  }
  
  getGenerator(personalityName, personalityData = null) {
    const normalizedName = personalityName.toLowerCase().trim();
    
    // 1. Check for hard-coded specialized generator first (highest quality)
    if (this.generators.has(normalizedName)) {
      console.log(`ðŸŽ¯ Using hard-coded ${normalizedName} response generator`);
      return this.generators.get(normalizedName);
    }
    
    // 2. Check for cached auto-generated generator
    if (this.autoGeneratedCache.has(normalizedName)) {
      console.log(`ðŸ¤– Using cached auto-generated ${normalizedName} response generator`);
      return this.autoGeneratedCache.get(normalizedName);
    }
    
    // 3. Try to auto-generate from provided personality data
    if (personalityData && this.hasUsableCognitiveTraits(personalityData)) {
      console.log(`ðŸ¤– Auto-generating response generator for ${personalityName} from provided data`);
      const autoGenerator = this.createAutoGeneratedGenerator(personalityName, personalityData);
      this.autoGeneratedCache.set(normalizedName, autoGenerator);
      return autoGenerator;
    }
    
    // 4. Try to auto-generate from personality registry
    const registryData = this.personalityRegistry.get(normalizedName);
    if (registryData && this.hasUsableCognitiveTraits(registryData)) {
      console.log(`ðŸ¤– Auto-generating response generator for ${personalityName} from registry`);
      const autoGenerator = this.createAutoGeneratedGenerator(personalityName, registryData);
      this.autoGeneratedCache.set(normalizedName, autoGenerator);
      return autoGenerator;
    }
    
    // 5. Fallback to generic generator
    console.log(`ðŸ”§ Using generic response generator for ${personalityName}`);
    return this.genericGenerator;
  }
  
  createAutoGeneratedGenerator(personalityName, personalityData) {
    const cognitiveTraits = this.extractCognitiveTraits(personalityData);
    const knowledgeDomains = this.extractKnowledgeDomains(personalityData);
    
    return new PersonalityGeneratorTemplate(
      personalityName,
      cognitiveTraits,
      knowledgeDomains,
      personalityData
    );
  }
  
  hasUsableCognitiveTraits(personalityData) {
    const traits = this.extractCognitiveTraits(personalityData);
    return Object.keys(traits).length > 0;
  }
  
  extractCognitiveTraits(personalityData) {
    const traits = {};
    
    // Check for direct cognitive traits
    if (personalityData.cognitiveTraits) {
      Object.assign(traits, personalityData.cognitiveTraits);
    }
    
    // Extract from personality structure
    if (personalityData.personality?.cognitiveTraits) {
      Object.assign(traits, personalityData.personality.cognitiveTraits);
    }
    
    // Extract from ideology principles (convert to traits)
    if (personalityData.ideology?.principles) {
      personalityData.ideology.principles.forEach(principle => {
        const traitName = this.principleToTraitName(principle);
        traits[traitName] = {
          description: principle,
          expertise: 70, // Default expertise level
          strength: 0.7
        };
      });
    }
    
    // Extract from identity role (convert to traits)
    if (personalityData.identity?.role) {
      const role = personalityData.identity.role.toLowerCase();
      if (role.includes('architect')) {
        traits['architecturalThinking'] = { expertise: 80, description: 'Architectural design and systems thinking' };
      }
      if (role.includes('analyst') || role.includes('hunter')) {
        traits['forensicAnalysis'] = { expertise: 80, description: 'Evidence-based analysis and investigation' };
      }
      if (role.includes('optimizer') || role.includes('performance')) {
        traits['performanceOptimization'] = { expertise: 80, description: 'Performance analysis and optimization' };
      }
      if (role.includes('designer') || role.includes('aesthetic')) {
        traits['aestheticDesign'] = { expertise: 80, description: 'Visual design and aesthetic optimization' };
      }
    }
    
    return traits;
  }
  
  extractKnowledgeDomains(personalityData) {
    const domains = [];
    
    // Extract from cognitive traits
    if (personalityData.cognitiveTraits) {
      Object.values(personalityData.cognitiveTraits).forEach(trait => {
        if (trait.knowledgeDomains) {
          domains.push(...trait.knowledgeDomains);
        }
      });
    }
    
    // Extract from identity and role
    if (personalityData.identity?.role) {
      const role = personalityData.identity.role.toLowerCase();
      if (role.includes('architect')) domains.push('architecture', 'design', 'systems', 'patterns');
      if (role.includes('analyst')) domains.push('analysis', 'evidence', 'investigation', 'data');
      if (role.includes('optimizer')) domains.push('performance', 'optimization', 'efficiency', 'speed');
      if (role.includes('designer')) domains.push('design', 'visual', 'aesthetic', 'interface');
      if (role.includes('engineer')) domains.push('engineering', 'technical', 'implementation', 'construction');
    }
    
    // Remove duplicates
    return [...new Set(domains)];
  }
  
  principleToTraitName(principle) {
    const lower = principle.toLowerCase();
    if (lower.includes('systematic')) return 'systematicThinking';
    if (lower.includes('evidence')) return 'evidenceBasedAnalysis';
    if (lower.includes('optimization')) return 'optimizationFocus';
    if (lower.includes('precision')) return 'precisionAnalysis';
    if (lower.includes('quality')) return 'qualityAssurance';
    if (lower.includes('architectural')) return 'architecturalThinking';
    if (lower.includes('forensic')) return 'forensicAnalysis';
    if (lower.includes('performance')) return 'performanceOptimization';
    
    // Default: convert to camelCase trait name
    return principle.replace(/[^a-zA-Z0-9]/g, '').toLowerCase() + 'Trait';
  }
  
  registerPersonality(personalityName, personalityData) {
    const normalizedName = personalityName.toLowerCase().trim();
    this.personalityRegistry.set(normalizedName, personalityData);
    
    // Clear any cached auto-generated generator to force refresh
    if (this.autoGeneratedCache.has(normalizedName)) {
      this.autoGeneratedCache.delete(normalizedName);
    }
    
    console.log(`ðŸ“‹ Registered personality: ${personalityName}`);
  }
  
  hasSpecializedGenerator(personalityName) {
    const normalizedName = personalityName.toLowerCase().trim();
    return this.generators.has(normalizedName) || 
           this.autoGeneratedCache.has(normalizedName) ||
           this.hasUsableCognitiveTraits(this.personalityRegistry.get(normalizedName));
  }
  
  getAvailableSpecializations() {
    const hardCoded = Array.from(this.generators.keys());
    const autoGenerated = Array.from(this.autoGeneratedCache.keys());
    const registryAvailable = Array.from(this.personalityRegistry.keys()).filter(name => 
      this.hasUsableCognitiveTraits(this.personalityRegistry.get(name))
    );
    
    return {
      hardCoded,
      autoGenerated,
      registryAvailable,
      all: [...new Set([...hardCoded, ...autoGenerated, ...registryAvailable])]
    };
  }
  
  getGeneratorStatus() {
    const specializations = this.getAvailableSpecializations();
    const totalPersonalities = 8; // Known personality count
    const hardCoded = specializations.hardCoded.length;
    const autoGenerated = specializations.autoGenerated.length;
    const registryAvailable = specializations.registryAvailable.length;
    
    return {
      hardCoded,
      autoGenerated,
      registryAvailable,
      total: totalPersonalities,
      coverage: `${hardCoded}+${autoGenerated}+${registryAvailable}/${totalPersonalities}`,
      generationCapability: 'infinite-scaling'
    };
  }
  
  clearAutoGeneratedCache() {
    this.autoGeneratedCache.clear();
    console.log('ðŸ§¹ Auto-generated generator cache cleared');
  }
}
